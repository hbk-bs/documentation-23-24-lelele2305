<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta http-equiv="x-ua-compatible" content="ie=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
		<title>Dokumentation Digitale Kommunikation</title>
		<meta name="description" content="something" />
		<meta name="author" content="me" />

		<link rel="stylesheet" type="text/css" href="/style.css" />
	</head>

	<body>

        <nav class="navigation_bar">
			<div class="nav_logo">LM Doku</div>
			<a href="#" class="toggle-button">
				<span class="bar"></span>
				<span class="bar"></span>
				<span class="bar"></span>
			</a>
			<div class="list-container">
				<ul class="ulindex">
					<li class="liindex"><a href="index.html">Herzlich Willkommen</a></li>
					<li class="liindex"><a href="Perspektiven.html">Perspectives</a></li>
					<li class="liindex"><a href="#">Little tools</a></li>
					<li class="liindex"><a href="Abschlussprojekt.html">The sleeping uncle</a></li>
				</ul>
			</div>
		</nav>

		<aside class="seite"></aside>

		<h1>Ein interaktives Tool</h1>
        <p>Hier kannst du mehr über die verwendeten Plattformen erfahren:</p>

        <article>
			<div class="github">
			<details>
			<summary>Github</summary>

			<p>Für dieses Projekt und weitere mussten wir Replit aufgeben. 
				Durch angekündigte Einschränkungen sind wir auf Github umgestiegen.
				Mit Github funktioniert alles etwas anders, als bei Replit. 
			</p>

			<figure>
				<img id="githubimg" class="Tool" src="assets/images/BenutzeroberflacheGithub.png" 
				alt="Benutzeroberfläche von Github" 
				title="Github">
				<figcaption id="githubfig" class="Bildunterschrift">Die Benutzeroberfläche von Github.</figcaption>
			</figure>

			<p>
				Bei Github handelt es sich um eine Plattform für die Versionsverwaltung und die 
				Zusammenarbeit bei der Softwareentwicklung. Es gibt hier die grundlegenden Konzepte:
				Repositories, Commits, Branches, Pull-Requests, Forks und Issues. Diese werden im Folgenden 
				nochmal einzeiln erklärt. Github wird von Entwicklern auf der ganzen Welt genutzt, um
				gemeinsam an Projekten zu arbeiten, Code zu verwalten und Software zu entwickeln.
				Also eine leistungsfähige Plattform, die die Zusammenarbeit und Transparenz in der 
				Softwareentwicklung erleichert.
				<ol>
					<li><strong>Repositories:</strong> </br>Ein Repository ist ein Speicherort für ein Projekt. 
						Es enthält alle Dateien, Verlaufsinformationen und Änderungen für das Projekt.</li>
					<li><strong>Commits:</strong> </br>Ein Commit ist eine einzelne Änderung oder ein Satz von Änderungen an 
						einer Datei (oder mehreren Dateien). Jeder Commit hat eine Beschreibung, die erklärt, 
						was geändert wurde.</li>
					<li><strong>Branches:</strong></br> Ein Branch ist eine separate Version des Codes innerhalb eines Repositories. 
						Entwickler können Branches erstellen, um neue Funktionen zu entwickeln oder Fehler zu beheben, 
						ohne den Hauptcode zu beeinträchtigen.</li>
					<li><strong>Pull Requests:</strong></br> Wenn ein Entwickler eine Änderung vornimmt und diese in den Hauptcode 
						integrieren möchte, stellt er eine Pull-Anforderung. Andere Entwickler können dann den Code überprüfen, 
						Kommentare abgeben und Änderungen vorschlagen, bevor die Änderung in den Hauptcode übernommen wird.</li>
					<li><strong>Forks:</strong></br> Ein Fork ist eine Kopie eines Repositories. Entwickler können ein Repository fork, 
						um Änderungen vorzunehmen, ohne das Original zu beeinträchtigen. Sie können dann eine Pull-Anforderung 
						stellen, um ihre Änderungen wieder in das Original-Repository zu integrieren.</li>
					<li><strong>Issues:</strong></br> Issues sind Aufgaben, Fehlerberichte oder Diskussionen zu einem Projekt. 
						Entwickler können Issues erstellen, um Probleme zu verfolgen oder neue Funktionen vorzuschlagen.</li>
				</ol>
				Im Gegensatz zu Replit hat Github keine integrierte Entwicklungsumgebung. Unseren Code
				schreiben wir daher in Visual Studio Code. Mit Hilfe des Github Desktops lassen sich die Änderungen
				ganz einfach von Visual Studio Code auf Github selbst ins Repository pushen. 
				Mit Netlify kann man sich das Ganze dann auch im Web anschauen.
			</p>
		    </details>
		    </div>

			<details class="githubdesktop">
				<summary>Github Desktop</summary>	
			<p>Github Desktop ist eine Anwendung, die von Github entwickelt wurde und es Benutzern ermöglicht, Github ohne die
				Notwendigkeit von Befehlszeilenoperationen zu nutzen. ES vereinfacht das Arbeiten mit Git-Repositories. Die 
				Hauptfunktionen von Github Desktop sind: 
				<ol>
					<li><strong>Repository-Verwaltung:</strong></br> Benutzer können Repositories erstellen, klonen, aktualisieren, 
						löschen und zwischen ihnen wechseln. Dies kann alles über eine einfache Benutzeroberfläche erfolgen, ohne 
						dass Git-Befehle eingegeben werden müssen.</li>
					<li><strong>Branch-Management:</strong></br> GitHub Desktop ermöglicht das Erstellen, Wechseln, Löschen und Zusammenführen 
						von Branches. Benutzer können auch Pull-Requests direkt aus der Anwendung heraus erstellen und überprüfen.</li>
					<li><strong>Committing und Synchronisierung:</strong></br> Benutzer können ihre Änderungen in ihren Repositories committen 
						und synchronisieren. GitHub Desktop zeigt Änderungen grafisch an und ermöglicht es Benutzern, Nachrichten zu ihren 
						Commits hinzuzufügen.</li>
					<li><strong>Kollaboration:</strong></br> Benutzer können einfach mit anderen Entwicklern zusammenarbeiten, indem sie auf 
						ihre Repositories zugreifen, Pull-Requests erstellen und Code überprüfen.</li>
					<li><strong>History- und Differenzanzeige:</strong></br> GitHub Desktop ermöglicht es Benutzern, die Historie ihrer Commits 
						sowie die Unterschiede zwischen verschiedenen Commits oder Branches zu sehen.</li>
				</ol>
			</p>

			<figure>
				<img id="gitdeskimg" class="Tool" src="assets/images/GithubDesktopChanges.png" 
				alt="Github Desktop Änderungen schreiben" 
				title="GithubDesktop">
				<figcaption id="gitdeskfig" class="Bildunterschrift">Die Bezeichnung der Änderungen in Github Desktop schreiben.</figcaption>
			</figure>

			<figure>
				<img id="gitdeskimg" class="Tool" src="assets/images/GithubDesktopPush.png" 
				alt="Github Desktop Änderungen pushen" 
				title="GithubDesktop">
				<figcaption id="gitdeskfig" class="Bildunterschrift">Die Bezeichnung der Änderungen in Github Desktop pushen.</figcaption>
			</figure>

			<figure>
				<img id="gitdeskimg" class="Tool" src="assets/images/GithubDesktopBranch.png" 
				alt="Github Desktop Branch" 
				title="GithubDesktop">
				<figcaption id="gitdeskfig" class="Bildunterschrift">Die Branches bei Github Desktop.</figcaption>
			</figure>

			<p><strong>Probleme mit Github:</strong></br> Durch die relativ kurzfristige Umstellung auf Github gab es zu Beginn Schwierigkeiten 
				bei der Einfindung in die neue Plattform. Zwar kann man hier auch online zusammen an einem Code arbeiten, 
				jedoch ist das alles dann doch anders aufgebaut. Durch die Routinierung der Abfolgen wurde mir erst wirklich
				klar, wann welcher Schritt kommt. Die verschiedenen Branches haben mich am Anfang sehr irritiert und ich habe 
				öfter mal versehentlich im main Branch gearbeitet, obwohl ich mir einen eigenen Branch erstellen sollte. Auch 
				die Pull Requests haben bei mir für Verwirrung gesorgt. 
			</p>
			<p><strong>Umgang mit Github jetzt:</strong></br> Die genannten Probleme bestanden nur temporär. Man lernt ja immer etwas dazu.
				Wenn ich mit Github, Netlify und Visual Studio Code jetzt an meiner okumentation arbeite habe ich keine 
			    großen Probleme, die nicht zeitnah durch Ausprobieren funktionieren würden. Ich kann mir auch in Zukunft 
			    vorstellen, weiterhin mit Github zu arbeiten und mehr Erfahrungen im Umgang mit der Plattform zu sammeln.
			    Möglicherweise begegnet sie mir sowieso im Berufsleben wieder!</p>
			</details>
		   

			<details class="vscode">
			<summary>Visual Studio Code</summary>

			<p>Visual Studio Code (VS Code) ist ein kostenloser plattformübergreifender Code-Editor. Er bietet eine vielzahl von
				Funktionen, doe die Entwicklung und Bearbeitung von Code erleichtern. Einige wichtige Merkmale von 
				VS Code sind:
				<ul>
					<li><strong>Plattformübergreifend:</strong></br> ist für Windows, macOS und Linux verfügbar.</li>
					<li><strong>Leichtgewichtig:</strong></br> ressourcenschonend und startet schnell. Es ist kein vollständiges integriertes 
						Entwicklungsumgebung (IDE) wie Visual Studio, sondern ein Editor mit vielen Erweiterungen, die nach Bedarf 
						hinzugefügt werden können.</li>
					<li><strong>Integrierte Entwicklungsumgebung (IDE)-Funktionen:</strong></br> bietet aber viele Funktionen einer 
						vollständigen IDE, wie z. B. Syntaxhervorhebung, Codevervollständigung, Integrierte Git-Unterstützung, 
						Debugging-Unterstützung, automatische Codeformatierung und vieles mehr.</li>
						<li><strong>Erweiterbarkeit:</strong></br> Durch die Installation von Erweiterungen können Entwickler Funktionalitäten 
						und Sprachunterstützung für eine Vielzahl von Programmiersprachen hinzufügen, Themes anpassen und weitere 
						Funktionen nach Bedarf integrieren.</li>
				</ul>
			</p>
		    </details>

			<details class="netlify">
			<summary>Netlify</summary>

			<figure>
				<img id="netlifyimg" class="Tool" src="assets/images/Netlify.png" 
				alt="Die Netltify-Benutzeroberfläche" 
				title="Netltify-Benutzeroberfläche">
				<figcaption id="netlifyfig" class="Bildunterschrift">Die Benutzeroberfläche von Netlify.</figcaption>
			</figure>

	           <p>Netlify ist eine Cloud-Plattform, die sich auf die Bereitstellung und das Hosting von statischen Websites sowie
				  von serverseitig generierten JavaScrips-Apps spezialisiert hat. Auch hier möchte ich einige Merkmale nennen:
				  <ol>
					<li><strong>Statische Website-Hosting:</strong></br> Netlify ermöglicht es Entwicklern, statische Websites einfach und 
						schnell zu hosten. Dies umfasst Websites, die nur aus HTML, CSS und JavaScript bestehen, ohne Serverseitiges Backend.</li>
					<li><strong>Continous Deployment:</strong></br> Netlify bietet eine nahtlose Continuous Deployment-Integration, die es 
						Entwicklern ermöglicht, ihre Websites automatisch zu aktualisieren, sobald Änderungen im zugehörigen Git-Repository 
						vorgenommen werden. Dies bedeutet, dass Änderungen sofort live gehen können, ohne dass manuelle Bereitstellungsschritte 
						erforderlich sind.</li>
					<li><strong>Serverless Functions:</strong></br> Netlify bietet die Möglichkeit, serverlose Funktionen zu erstellen und zu hosten, 
						die über HTTP-Aufrufe erreichbar sind. Dies ermöglicht es Entwicklern, dynamische Inhalte hinzuzufügen, ohne eine 
						separate Serverinfrastruktur verwalten zu müssen.</li>
					<li><strong>Global CDN:</strong></br> Netlify nutzt ein globales Content Delivery Network (CDN), um Inhalte schnell und 
						effizient an Benutzer auf der ganzen Welt zu verteilen. Dadurch werden die Ladezeiten reduziert und die Leistung 
						der gehosteten Websites verbessert.</li>
					<li><strong>Automatisches Formularmanagement:</strong></br> Netlify bietet eine integrierte Lösung zur Verwaltung von Formularen 
						auf statischen Websites. Es ermöglicht das Einrichten von Formularen mit Validierung, Speicherung von Formulardaten und 
						Benachrichtigungen über Formulareingaben.</li>
					<li><strong>Branch Deployments:</strong></br> Entwickler können verschiedene Branches ihres Projekts auf unterschiedlichen URLs 
						bereitstellen, um neue Funktionen zu testen oder Änderungen vor der Veröffentlichung zu überprüfen.</li>
				  </ol>
			   </p>
			   </details>


			<h2 class="littletoolh2">"Little tools"</h2>

			<p>Nach dieser Einführung in die neuen Plattformen möchte ich  mein Projekt vorstellen, welches ich unter dem 
				Namen "Little tools" entwickelt habe. Es handelt sich um ein webbasiertes Zeichentool. Links gibt es eine kleine
				Einstellungsbar und rechts daneben befindet sich die Zeichenfläche. Man kann wählen zwischen Brush (Pinsel) und 
				Eraser (Radierer) und darunter mit Hilfe eines Schiebereglers jeweils die Größe einstellen. Darunter wiederum 
				befinden sich ausgewählte Farben, mit denen man pinseln kann. Man kann sich aber auch selbst seine Farbe 
				raussuchen. dazu muss man nur auf den äußeren rechten Farbkreis klicken. Dann öffnet sich ein Feld mit weiteren
				wählbaren Farben. Des Weiteren kann man die Zeichenoberfläche durch Drücken des Buttons "CLEAR" wieder auf null 
				zurücksetzen oder aber auch die Zeichenfläche so bemalt wie sie ist, speichern. Indem man auf "SAVE" drückt, wird 
				eine JPG erstellt, der du einen Namen geben und an einem ausgewählten Ort speichern kannst. 
			</p>

			<figure>
				<img class="Tool" src="assets/images/Malen.png" 
				alt="Malen mit meinem little tool" 
				title="Little tool">
				<figcaption class="Bildunterschrift">Das Malen mit meinem little tool.</figcaption>
			</figure>

			<figure>
				<img class="Tool" src="assets/images/Farbfelder.png" 
				alt="Farbfelder meines little tools" 
				title="Little tool">
				<figcaption class="Bildunterschrift">Die Farbfelder meines little tools.</figcaption>
			</figure>

			<figure>
				<img class="Tool" src="assets/images/littletoolsindex.png" 
				alt="Die index.html von little tools" 
				title="little tools index.html">
				<figcaption class="Bildunterschrift">Die Index.html von "little tools".</figcaption>
			</figure>
		</article>

		<div>
			<p>
				Du kannst dir im Folgenden gerne den JavaScript-Code zu diesem Tool anschauen:
			</p>

			<details class="javadetail">
			<summary class="javascriptcode">JavaScript-Code:</summary>
			  <div class="Code">
				<code>
					const canvas = document.querySelector("canvas"), </br>
				    toolBtns = document.querySelectorAll(".tool"), </br>
				    sizeSlider = document.querySelector("#size-slider"), </br>
				    colorBtns = document.querySelectorAll(".colors .option"), </br>
				    colorPicker = document.querySelector("#color-picker"), </br>
				    clearCanvas = document.querySelector(".clear-canvas"),  </br>
				    saveImg = document.querySelector(".save"), </br>
				    ctx = canvas.getContext("2d");  //returns a drawing context on the canvas </br>
				</code>

				<p class="codedefinition">
					Hier werden die jeweiligen Elemente ausgewählt und einer Konstanten oder einer Variable
					zugeordnet.
				</p>
			  </div>

			  <div class="Code">
				<code>
				    let isDrawing = false; </br>
				    selectedTool = "brush", </br>
				    brushWidth = 5, </br>
				    selectedColor = "#000"; </br>
				</code>

				<p class="codedefinition">
					Den Variablen werden bestimmte Werte zugeordnet, Beim öffnen des Tools ist z.B. der Pinsel 
					bereits ausgewählt und die Breite auf 5 gestellt. 
				</p>
			  </div>

			  <div class="Code">
				<code>
				    const setCanvasBackground = () => { </br>
					    ctx.fillStyle = "#fff"; </br>
					    ctx.fillRect(0, 0, canvas.width, canvas.height); </br>
					    ctx.fillStyle = selectedColor; </br>
				    } </br>
				</code>

				<p class="codedefinition">
					Diese Funktion füllt den gesamten Canvas mit einer Hintergrundfarbe und stellt sicher, 
					dass die ausgewählte Zeichenfarbe für nachfolgende Zeichenoperationen eingestellt ist.
				</p>
			  </div>

			  <div class="Code">
				<code>	
				    window.addEventListener("load", () => { </br>
					    //setting canvas width/height.. offfsetwidth/height returns viewable width/height of an element </br>
					    canvas.width = canvas.offsetWidth; </br>
					    canvas.height = canvas.offsetHeight; </br>
					    setCanvasBackground(); </br>
				    }); </br>
			    </code>

				<p class="codedefinition">
					Der Code wird ausgeführt, wenn die Seite vollständig geladen ist und stellt sicher, dass
					die Breite und Höhe des Canvas an die des Containers angepasst werden, um eine korrekte 
					Darstellung zu gewährleisten. Dann wird der Hintergrund des canvas gesetzt.
				</p>
			  </div>
				
			  <div class="Code">
				<code>
				    const startDraw = () => { </br>
					    isDrawing = true; </br>
					    ctx.beginPath(); //creating new path to draw </br>
					    ctx.lineWidth = brushWidth;  //brushsize for the line </br>
					    ctx.strokeStyle = selectedColor;  </br>
				    } </br>
			    </code>

				<p class="codedefinition">
					Diese Funktion ist für den Beginn des Zeichnens. Es werden alle erforderlichen Einstellungen
					für das Zeichnen getroffen. Sie legt also fest, wie dick und welche Farbe gewählt ist und dass 
					der Benutzer zeichnet. Jetzt kann direkt also das Zeichnen beginnen.
				</p>
			  </div>
				
			  <div class="Code">
				<code>
				    const drawing = (e) => { </br>
					    if(!isDrawing) return; //if isDrawing is false return from here </br>
				    </br>
					    if(selectedTool === "brush" || selectedTool === "eraser") { </br>
					    ctx.strokeStyle = selectedTool === "eraser" ? "#fff" : selectedColor; </br>
					    ctx.lineTo(e.offsetX, e.offsetY); //creating line according to the mouse pointer </br>
					    ctx.stroke(); //drawing line with color </br>
					    } </br>
					
				    } </br>
			    </code>

				<p class="codedefinition">
					Wenn der Benutzer den Pinsel oder das Radiergummi verwendet und die Maus bewegt, zeichnet diese Funktion
					die Linie auf dem Canvas. Falls nichts dergleichen geschieht, passiert in dieser Funktion auch nichts.
				</p>
			  </div>
				
			  <div class="Code">
				<code>
				    toolBtns.forEach(btn => { </br>
					    btn.addEventListener("click", () => {  //click event to tool options </br>
						    //removing active class from the previous option and adding on current clicked option </br>
						    document.querySelector(".options .active").classList.remove("active"); </br>
						    btn.classList.add("active"); </br>
						    selectedTool = btn.id; </br>
						    console.log(selectedTool); </br>
					    }); </br>
				    }); </br>
			    </code>

				<p class="codedefinition">
                    Dieser Code sorgt dafür, dass das ausgewählte Tool visuell hervorgehoben wird und die entsprechenden 
					Variablenwerte aktualisiert werden, wenn der Benutzer auf eine Werkzeug-Schaltfläche klickt.
				</p>
			  </div>
				
			  <div class="Code">
				<code>
				    sizeSlider.addEventListener("change", () => brushWidth = sizeSlider.value); //passing slider value as brush size </br>
			    </code>

				<p class="codedefinition">
					Diese Zeile sorgt dafür, dass die Pinselbreite aktualisiert wird, wenn der Benutzer die Größe
					des Pinsels über den Schieberegler verändert.
				</p>
			  </div>

			  <div class="Code">
				<code>
				    colorBtns.forEach(btn => { </br>
					    btn.addEventListener("click", () => {  //click event for color buttons </br>
						    document.querySelector(".options .selected").classList.remove("selected"); </br>
						    btn.classList.add("selected"); </br>
						    //passing selected btn background color as selcetdColor value </br>
						    selectedColor = window.getComputedStyle(btn).getPropertyValue("background-color"); </br>
					    }); </br>
				    }); </br>
			    </code>

				<p class="codedefinition">
					Die ausgewählte Farbe wird visuell hervorgehoben und die entsprechenden Variablenwerte werden aktualisiert, 
					wenn der Benutzer auf eine Farb-Schaltfläche klickt.
				</p>
			  </div>
				
			  <div class="Code">
				<code>
				    colorPicker.addEventListener("change", () => { </br>
					    //passing picked color value from color picker to last color btn background </br>
					    colorPicker.parentElement.style.background = colorPicker.value; </br>
					    colorPicker.parentElement.click(); </br>
				    }); </br>
			    </code>

				<p class="codedefinition">
					Mit diesem Code ist es dem Benutzer möglich eine Farbe im Farbwähler auszuwählen.
					Er stellt sicher, dass diese farbe sofort im UI angezeigt und angewendet wird.
				</p>
			  </div>
				
			  <div class="Code">
				<code>
				    clearCanvas.addEventListener("click", () => { </br>
					    ctx.clearRect(0, 0, canvas.width, canvas.height); //clearing canvas </br>
					    setCanvasBackground(); </br>
				    }); </br>
			    </code>

				<p class="codedefinition">
					Es wird dafür gesorgt, dass beim Klicken auf "CLEAR" der gesamte Inhalt des Canvas
					gelöscht wird und der Hintergrund wiederhergestellt wird.
				</p>
			  </div>
				
			  <div class="Code">
				<code>
				    saveImg.addEventListener("click", () => { </br>
				       const link = document.createElement("a"); </br>
				       link.download = `${Date.now()}.jpg`; </br>
				       link.href = canvas.toDataURL(); </br>
					   link.click(); </br>
				    }); </br>
			    </code>

				<p class="codedefinition">
					Beim Klicken auf den Button "SAVE" wird das Bild im Canvas heruntergeladen. 
					Der Dateiname wird mit dem aktuellen Zeitstempel versehen.
				</p>
			  </div>
				
			  <div class="Code">
				<code>
				    canvas.addEventListener("mousedown", startDraw); </br>
				    canvas.addEventListener("mousemove", drawing); </br>
				    canvas.addEventListener("mouseup", () => isDrawing = false); </br>
				</code>

				<p class="codedefinition">
					Diese Event-Listener ermöglichen es, mit der Maus auf dem Canvas zu interagieren, um
					Zeichenoperationen durchzuführen, wie z.B. Linien zu ziehen, wenn die Maus bewegt wird, 
					während die linke Maustaste gedrückt wird.
				</p>
			  </div>
			</details>
		</div>

		<p class="endsatz">Wie hat dir "Perspectives" gefallen?</p>
        <p class="nächstseite">Hier geht es weiter zum Projekt <a class="azulittletools" href="Abschlussprojekt.html">"The sleeping uncle"</a>...</p>
		
		<footer>
			<p>©2024 Dokumentation Digitale Kommunikation Grundlagenseminar 1. Semester Leonie Manthey</p>
		</footer>

		<script type="text/javascript" src="/index.js"></script>
	</body>
</html>
